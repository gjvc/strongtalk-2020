<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
    <title>The User Interface Framework</title></head>
<body bgcolor="#FFFFFF"><h3 align="right"><a href="mixins.html">&lt;== Previous</a> |<a href="toc.html">Contents</a> |<a href="conclusion.html"><strong>Next ==&gt;</strong></a></h3>
<h2 align="left">The User Interface Framework</h2>
<p>The Strongtalk user interface framework departs considerably from the Model-View-Controller framework of Smalltalk-80. It has a number of interesting design freatures:</p>
<ul>
    <li>Use of flyweight <em>glyphs </em>(an idea borrowed from Calder's implementation in the InterViews system). A glyph is a shareable widget, i.e. it can have many parents. This shareability allows them to be used in a much more fine-grained manner than normal widgets (called<em>Visuals</em> in the Strongtalk system). For example, every character on this page is represented by an individual glyph that manages its own layout and rendering.</li>
    <li>Advanced, automatic dynamic layout using a shrink/stretch model computed from minimum/desired/maximum sizes. A layout is specified by combining a number of standard visuals such as Row, Column, Table, and Glue, which then manage the layout process for the application. For example, the lines of text on this page are actually just standard GlyphRow visuals, that knows how to lay things out horizontally. <p>The goal is that applications should normally not have to create their own subclasses of Visual, or worry about doing layout on their own, which is fraught with difficulty in most systems as soon as layouts become dynamic. This works nicely; for example, the entire programming environment in Strongtalk was designed without creating a single additional Visual subclass, or doing any layout other than using the standard layout widgets.</p></li>
    <li>The layout mechanism uses lazy relayout and intelligent layout reordering to eliminate the algorithmic problems seen in most other UI frameworks whereby widgets inadvertently get layed out and redrawn multiple times when simple changes are made.</li>
    <li>The UI framework provides a framework for imbedding true native widgets into any place in any Visual layout, which is traditionally a shortcoming of most Smalltalk systems. A subset of the Visual classes support many of the standard native aspects of the UI (buttons, check boxes, listboxes, dialogs, message boxes, and scrollbars)</li>
    <li>The framework's API is designed to be highly portable (although some parts require a different implementation on other platforms). Native widgets are represented by Visual subclasses that abstract their behavior in a portable way.</li>
</ul>
<p>Visuals are responsible for the <em>physical</em> aspects of the UI (layout, rendering, event processing, etc). Separate wrapper visuals can be used to control and modify event processing, taking the place of the separate Controller hierarchy in other Smalltalk systems. Glyphs and Visuals interact smoothly: all Visuals are Glyphs, and any glyph can be wrapped for use as a Visual with the message #asVisual.</p>
<p>Application and model-specific logic is placed in a separate hierarchy, the Application hierarchy. Applications are responsible for creating and parameterizing the Visual instances they need, handling logical interaction. A subclass of Application, View, mediates between Visuals and model objects.</p>
<p>Because the Strongtalk UI framework is strongly-typed, it uses Blocks to parameterize the behavior of Visuals, rather than using the selector/perform approach used in other Smalltalk systems.</p>
<p>Here is a hierarchy browser showing the UI framework public API:</p>
<p align="center">
    <smappl visual=" | h v | h := (ClassHierarchyOutliner for: (ClassMirror on: Object)) filterOnUIUserClasses. v := (h topVisualWithHRule: false) withBorder: (Border standard3DRaised: true). v"><br><strong>The UI framework public API</strong><a DOIT="  (ClassHierarchyOutliner for: (ClassMirror on: Object)) filterOnUIUserClasses; launch">(spawn)</a>
</p>
<p>If you are interested in looking at what kind of Visuals and Applications are in the windows you are looking at, there are two neat tools for doing that directly. First, most of strongtalk applications have a &quot;Meta&quot; menu item on their main menu. This will open an inspector on the Application object associated with that window.</p>
<p>To look at the Visuals associated with any point in any Strongtalk window, you can open a <em>Core Sampler</em> by clicking <a DOIT=" CoreSampler new launch">here</a>. Once a core sampler is open, clicking the left mouse button while holding down the &lt;Ctrl&gt; key in any other window will display a list of inspectors on Visuals in the CoreSampler window. The list represents the slice of the Visual hierarchy that contains the point you clicked on, from outermost to innermost. Try ctrl-clicking on this line of text to see all the levels of glyphs and Visuals that make up an HTML browser page.</p>
<h3 align="right"><a href="conclusion.html">Next ==&gt;</a></h3></body>
</html>

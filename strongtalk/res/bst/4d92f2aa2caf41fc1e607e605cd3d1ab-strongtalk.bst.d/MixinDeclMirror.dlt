Delta define: #MixinDeclMirror as: (
(Class subclassOf: 'MixinMirror' instanceVariables: 'mixinDecl sourceInfo ') classVariables: 'InvocationInfo <VarDict[Mixin, AbstractInvocationData]>') !

(Delta mirrorFor: #MixinDeclMirror) revision: '$Revision: 1.23 $'!

(Delta mirrorFor: #MixinDeclMirror) group: 'reflection'!

(Delta mirrorFor: #MixinDeclMirror)
comment: 
'This class represents a mirror on a mixin declaration.

The mirror maintains an instance variable, mixinDecl, which is a low level mirror
(a MixinVMMirror) on the actual mixin. Changes are accomplished by forwarding
to this low level mirror. The actual mixin being reflected is also available thru mixinDecl.

Changes to the structure of the mixin are accomplished by creating an uninstalled copy
of the mixin, and performing the changes on it, and the installing the changes atomically
using the changed copy as a constructor which is passed to the VM. The VM also receives
a list of all invocations and their dependent subclasses, so that it can modify them atomically
at the same time.

This process is done using the makeChange:ifFail: method, which in turn invokes the
install:ifFail: method.

Methods are simply added to the mixin, and copied down to invocations. This is not done atomically
at this point.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'Unclassified' !


cleanUp

InvocationInfo keys do: [ :k | k name isNil ifTrue: [ InvocationInfo removeKey: k ]].

!

createInvocationOf: mixin <MixinMirror>  named: n <Symbol> superclass: sc <ClassMirror> ifFail: fb <[Str]> ^ <ClassVMMirror>
"h1"
"
create a named invocation of  mixin
"
| klass <ClassVMMirror>  |

klass := self createInvocationValueOf: mixin named: n superclass: sc ifFail: fb.
self addTypeStructureForInvocation: klass.
^klass!

createInvocationValueOf: mixin <MixinDeclMirror> named: n <Symbol>  superclass: sc <ClassMirror> ifFail: fb <[Str]> ^ <ClassVMMirror>
"b"
"
create a named invocation value of  mixin
"

| 
klass <ClassVMMirror> 
vmSuperclass <ClassVMMirror> 
vmMixin  <MixinVMMirror> 
|


(Delta includesKey: n) "previous version of n exists"
  ifTrue:[(Delta at: n) isError ifFalse:[ fb value: 'Internal failure: Class ', n , ' already exists']].
vmMixin := MixinVMMirror on: mixin reflectee.
vmSuperclass := ClassVMMirror on: sc reflectee.
klass := ClassVMMirror createInvocationOf: vmMixin named: n superclass: vmSuperclass ifFail: fb.
mixin addInvocation: klass reflectee.
^klass
!

init

	InvocationInfo := Dictionary [Mixin, AbstractInvocationData]  new.
!

on: mixin <Mixin> ^ <Instance> 

| mixinDecl <MixinVMMirror> |

mixinDecl := MixinVMMirror on: mixin.

^self new reflect: mixinDecl.!

superclassType: s  <Str>  body: b  <ClassMirror> ^ <Instance> 
	self deltaHack.  "Should go away once schema changes work"
	^b mixin superclassType: s! !

! (Delta mirrorFor: #MixinDeclMirror) classSide methodsFor: 'private' !


addBasicTypeStructureForInvocation: class <ClassVMMirror>
"Private" 
| classTypeInfo <MixinInvocationSide> classClassTypeInfo <MixinInvocationSide> |
classTypeInfo := Type atClass: class reflectee 
                                             put:  (DeltaMixinInvocationSide new initialize).
classClassTypeInfo := Type atClass: class classSide reflectee 
                                                        put: (DeltaMixinInvocationSide new initialize).
classTypeInfo  dual: classClassTypeInfo.
classClassTypeInfo  dual: classTypeInfo.
!

addSuperclassTypeStructureForInvocation: class <ClassVMMirror>

"Private" 
(Type forClass: class reflectee) superclassType: (self classReferenceTo: (class superclass nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass'])).
(Type forClass: class classSide reflectee) superclassType: (self metaclassReferenceTo: (class superclass nameIfAbsent:[self error: 'Internal flaw: Use of unnamed superclass'])).

!

addTypeStructureForInvocation: class <ClassVMMirror>
"e"
"Private"

self addBasicTypeStructureForInvocation: class.
(Type forClass: class reflectee) mixinType: (Type forMixin: class mixin reflectee).
(Type forClass: class classSide reflectee) mixinType: (Type forMixin: class mixin classSide reflectee).
self addSuperclassTypeStructureForInvocation: class.

!

addTypeStructureForMixin: mixin <MixinVMMirror>
"d"
"Private" 
| cDecl  <ClassUpdate> mixinTypeInfo <SideUpdate> |

cDecl := DeltaClassUpdate new  abstract: false; 
                                                       branded: true; 
                                                       monotonic: true; 
                                                       subtype: true.
mixinTypeInfo :=  DeltaSideUpdate new initialize.
cDecl instanceSide: mixinTypeInfo.

Type atMixin: mixin reflectee put: mixinTypeInfo.
Type atMixin: mixin classSide  reflectee put: (DeltaSideUpdate new initialize classDecl: cDecl).
(Type forMixin: mixin reflectee) superclassType:(self classReferenceTo: #Object).
(Type forMixin: mixin classSide reflectee) superclassType: (self metaclassReferenceTo: #Object).

!

computeDependentsOf: mixin <MixinDeclMirror> ^ <Array[Class]>
"Private"
"Here we collect all the invocations of mixin and all their subclasses"
| dependents <Array[Class]> |

dependents := Array[Class] new.
mixin vmInvocations do:[:vi <ClassVMMirror> | dependents addAll: vi subclasses].
^dependents.!

validate: m <MixinVMMirror> name: n <Symbol> superclass: sc <ClassMirror> ifFail: fb <[Str]>
"Private"
"This method performs certain checks to see if associating the name n
with an invocation of mixin could cause problems.

For example, the current version has methods that rely on instance, class or class instance
variables that are not available in mixin or in superclass.
 "! !

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !


abstract

self abstract: true!

abstract: b <Boolean>

self typeInfo abstract: b.
self sourceInfo abstract: b.!

addClassVariable: v  <VarDecl> ifFail: blk <[Str]>


self isMeta ifTrue:[blk value: 'One cannot add class variables to meta mixins'].
self makeChange:[:mvm <MixinVMMirror> | mvm addClassVarName: v name ifFail: blk]
        ifFail: blk.

self typeInfoAddClassVariable: v.!

addInstanceVariable: v  <VarDecl> ifFail: fb <[Str]>

self makeChange:[:mvm <MixinVMMirror> | mvm addInstVarName: v name ifFail: fb]
        ifFail: fb.

self typeInfoAddInstanceVariable: v.
          !

addInvocation: inv <Class>

self isMeta ifTrue: [ self error: 'Should not be called for meta-side' ].
self invocationInfo addInvocation: inv.
!

addMethod: mtd <DeltaMethod> to: inv <ClassVMMirror>
"
Private
"
| m <Method> |

m := self compileMethod: mtd within: inv ifFail:[:e <Str> | self error: 'Internal failure. Cannot compile ', mtd selector, ' within ', inv name, ' : ', e].
inv addMethod: m ifFail:[:e <Str> | self error: 'Internal failure. Cannot add ', mtd selector, ' to ', inv name, ' : ', e].!

addMethod: str <Str> visibility: vis <Symbol> category: cat <Symbol> ifFail: blk <[Str]> ^ <ParseTree>
	"This is the method to be called to add a method to a mixin"

	| pt <ParseTree> |

	pt := self insertMethod: str visibility: vis category: cat ifFail: blk.
	
	"We do not clear the body here since the caller may need the parse tree.
	The caller is responsible for sending #clearBody to the ast.
	All of this will go away once the type information no longer stores DeltaMethods."

	^pt
!

addPool: name <Str> ifFail: fb <[Str]>

self deltaHack.
self halt.!

basicDefinitionString  ^ <Str>

self isMeta 
  ifFalse:[^'Mixin superclassType: ', self superclassTypeString asString printString,  ' body: (', self body definitionString, ')']
  ifTrue:[self deltaHack. self shouldNotHappen].!

basicLocator  ^ <BasicMixinLocator> 
	^self typeInfo basicLocator!

body ^ <ClassMirror>

| newBody <ClassMirror> |

self superclassTypeString isEmpty "This is Object"
   ifTrue:[newBody := Class delta]
   ifFalse:[newBody :=  (Class subclassOf: self superclassTypeString
                                                         instanceVariables: self instanceVariableString).
                  ].
newBody := newBody
                                    classVariables: self classVariableString;
                                    protocols: self supportedProtocolString;
                                    classProtocols: self classSide supportedProtocolString.
newBody classInstanceVariables: self classSide instanceVariableString.

self isAbstract ifTrue:[newBody abstract].
self extensionsAreSubtypes ifFalse:[newBody extensionsAreNotSubtypes].
self isSubtype ifFalse:[newBody notSubtype].
self isBranded ifFalse:[newBody unbranded].
^newBody

         !

body: b  <ClassMirror>

self isMeta ifTrue:[self halt].
self conformToShape: b.
self conformBodyTypeTo:  b.

!

branded: b <Boolean>

self typeInfo branded: b.
self sourceInfo branded: b!

changeClassVariablesTo: list <Cltn[VarDecl]>
"Private"

| newDecls <Cltn[VarDecl]> existingDecls <Cltn[VarDecl]> deletedDecls <Cltn[VarDecl]> |

self nonAtomic.

newDecls := OrderedCollection[VarDecl] new.
existingDecls := OrderedCollection[VarDecl] new.
deletedDecls := OrderedCollection[VarDecl] new.

list do: [ :v <VarDecl> | 
	(self classVariableAt: v name ifAbsent: [ nil ]) isNil
		ifTrue: [ newDecls add: v ]
		ifFalse: [ existingDecls add: v ] ].

self classVariablesDo: [ :v <VarDecl> | 
	list detect: [ :e <VarDecl> | e name = v name ] ifNone: [ deletedDecls add: v ] ].

"Remove surplus inst vars"
deletedDecls do: [ :v <VarDecl> | 
	self removeClassVariable: v name ifAbsent: [ self error: 'Cannot remove class variable ', v name, ' from ', self name ] ].

"Add new inst vars"
newDecls do: [ :v <VarDecl> | 
	self addClassVariable: v  ifFail: [ self error: 'Cannot add class variable ', v name, ' to ', self name ] ].

"Update type information on existing inst vars"
existingDecls do: [ :v <VarDecl> | 
	(self classVariableAt: v name ifAbsent: [ self error: 'Should not happen' ]) name: v name type: v type ].

"
self removeAllClassVariables.
list do:[:v <VarDecl> | self addClassVariable: v 
                                                                ifFail:[:e <Str> | self error: 'Failed attempt to install class variable ', v name, ' in mixin ', self name, ' : ', e]].
"!

changeInstanceVariablesTo: list <Cltn[VarDecl]>
"Private"

| oldDecls <Cltn[VarDecl]> names <OrdCltn[Symbol]> |

self error: 'Should not be called anymore'.
self nonAtomic.
oldDecls := OrderedCollection[VarDecl] new.
self instanceVariablesDo: [ :v <VarDecl> | oldDecls add: v ].
names := list collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeInstanceVariablesTo: names]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old inst vars from the type info"
oldDecls do: [ :v <VarDecl> | 
	self typeInfoRemoveInstanceVariable: v name].

"Add new inst vars to the type info"
list do: [ :v <VarDecl> | 
	self typeInfoAddInstanceVariable: v].

!

changeMethod: oldAST <MethodDecl> to: newAST  <MethodDecl>

| typeInfo <SideUpdate>  |
" Private "
"Take whatever action is needed when a method changes from oldAST to newAST"

typeInfo := self typeInfo.
typeInfo errorHandler pushDefinition: typeInfo.
typeInfo errorHandler pushSelector: newAST selector.

" update dependencies"
self updateDependenciesFrom: oldAST to: newAST.

"Check if interface has changed, and take appropriate action"
self handleInterfaceChangeFrom: oldAST to: newAST.

typeInfo errorHandler popSelector.
typeInfo errorHandler popDefinition.!

changePoolsTo: list  <Cltn[Str]>

"Private"

self deltaHack.
self halt.
!

changeToMixin: mixin <MixinVMMirror> 
oldClasses: ocs <OrderedCollection[Class]>
newClasses: ncs <OrderedCollection[ClassMirror]>
ifFail: fb <[Str, ^DoesNotMatter]> ^ <MixinDeclMirror>

| 
existed <Boolean> 
invocations <SequenceableCollection[Class]>
change <Array[Mixin | Array[Class|Symbol]]>
cvns  <OrderedCollection[Symbol]>
mixinFormat <Symbol>
|

"If I mirror a meta mixin, I ask my instance side to install itself.  The installation is
always done in pairs, with the instance side as the argument to the primitive. "

self isMeta ifTrue:[^self instanceSide changeToMixin:  mixin instanceSide oldClasses: ocs newClasses: ncs  ifFail: fb].
ocs size = ncs size ifFalse:[fb value: 'Number of new classes does not match number of old classes'].
invocations := ClassVMMirror sort: self invocationInfo invocations. 
invocations isEmpty ifTrue:[self shouldNotHappen].
mixin name = self name ifFalse:[fb value: 'Attempt to replace mixin ', self name, ' with mixin ', mixin name].
mixinFormat := self mixinDecl format. 
"The format of the mixin itself can never change. If this turns out to be a problem, we will keep the format
in the VM"
change := Array[Mixin | Array[Class|Symbol]] new: 2 + invocations size.
change at: 1 put: mixin reflectee; 
                at: 2 put: self reflectee.
invocations with: (3 to: invocations size + 2)
						do:[: inv <Class> :i <Integer> |              
								change at: i put: (self prepareInvocation: inv mixinFormat: mixinFormat oldClasses: ocs newClasses: ncs ifFail: fb).
								].
{{primitiveApplyChange: change ifFail: [:e <CompressedSymbol> | fb value: e]}}.
ocs isEmpty ifFalse:[AbstractClassMirror flushSubclassHierarchyCache].
             
!

classProtocols: p  <Str> 

self classSide supportedProtocol: p!

classVariableAt: aName <Symbol> ifAbsent: aBlock <[]> ^ <VarDecl>

(self mixinDecl hasClassVarName: aName) ifFalse:[^aBlock value].
self classVariablesDo:[:v <VarDecl> | v name = aName ifTrue:[^v]].
^aBlock value.!

classVariableString ^ <Str>

^self isMeta ifTrue:[self deltaHack. self error: 'Ask non-metaclass for class variables string']
                        ifFalse:[self sourceInfo classVariableString].
!

classVariables: vars <Str>

| oldNames <Cltn[Symbol]> newNames <OrdCltn[Symbol]> newDecls <OrdCltn[VarDecl]> |

self deltaHack.
"We parse in a dummy scope since the parser insert the classvar decls in the scope and will complain about existing ones."
newDecls := (DeltaParser new parseClassVarList: vars within: (DeltaScope within: nil)) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals].

self nonAtomic.
oldNames := OrderedCollection[Symbol] new.
self classVariablesDo: [ :v <VarDecl> | oldNames add: v name ].
newNames := newDecls collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeClassVariablesTo: newNames]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old class vars from the type info"
oldNames do: [ :name <Symbol> | 
	self typeInfoRemoveClassVariable: name ].

newDecls do: [ :v <VarDecl> |
	self typeInfoAddClassVariable: v  ].

self sourceInfo classVariableString: vars.
!

classVariablesDo: blk <[VarDecl]>


"does this really take var decls?"
| typeInfo <SideUpdate> |

typeInfo := self typeInfo .
typeInfo  classVarDecls do: blk.
!

cloneConformingToShape: b <ClassMirror> ^ <MixinVMMirror>
"Private"
"Return a clone of myself,  whose shape conforms to that of b"
| clone <MixinVMMirror> |

clone := MixinVMMirror onCopyOf: self reflectee.
^self conform: clone toShape: b
!

combinedFormatOfMixin: m <Mixin> andSuperclass: sc <Class> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>

^ self combinedFormatOfMixinFormat: m format andSuperclassFormat: sc format ifFail:fb.!

combinedFormatOfMixinFormat: m <Symbol> andSuperclassFormat: sc <Symbol> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>
"Private"
sc = m ifTrue:[^m].
m = #Oops ifTrue:[^sc].
sc = #Oops ifTrue:[^m].


fb value: 'Incompatible formats: mixin has format ', m , ' and superclass has format ', sc.!

comment  ^ <Str> 

^self sourceInfo comment!

comment: c  <Str> 

self sourceInfo comment: c
!

compileMethod: m <DeltaMethod> ifFail: fb  <[Str]>  ^ <Method>
"Private"
	
	^self compileMethod: m within: self mixinDecl ifFail: fb!

compileMethod: m <DeltaMethod> within: d <ClassVMMirror | MixinVMMirror> ifFail: blk  <[Str]>  ^ <Method>
"Private"

	^(DeltaCompiler forClass: d optimize: false ifError: [:e <Str> | ^blk value: e]) compile: (DeltaRewriter new rewrite: m)!

compiledMethodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <Method | X>

	^self mixinDecl methodAt: selector ifFail: blk!

compiledMethodsDo: blk  <[Method]>

	self mixinDecl methodsDo: blk!

conform: m <MixinVMMirror> toShape: b <ClassMirror> ^ <MixinVMMirror>
"Private"
"make m's shape conform to that of b"
| noClassVars <Boolean> bvs <VarOrdCltn[Symbol]> |

b isMeta ifTrue:[self error: 'Attempt to modify meta mixin directly'].

bvs := OrderedCollection[Symbol] new.
b instanceVariablesDo:[:v <VarDecl> | bvs add: v name].
m changeInstanceVariablesTo: bvs.

bvs := OrderedCollection[Symbol] new.
b classVariablesDo:[:v <VarDecl> | bvs add: v name].
m changeClassVariablesTo: bvs.  

bvs := OrderedCollection[Symbol] new.
b mixin classSide instanceVariablesDo:[:v <VarDecl> | bvs add: v name].
m classSide changeInstanceVariablesTo: bvs.                                                  
              
" must eventually do same for pools"
^m
!

conformBodyTypeTo: b <ClassMirror>
"Private"
|  bType <SideUpdate> |

"modify type information"
self mayNeedToUnwind.
bType :=  (Type forMixin: b mixin reflectee).

self abstract: bType abstract.
self subtype: bType subtype.
self branded: bType branded.
self extensionsAreSubtypes: bType extensionsAreSubtypes.

self protocols: b mixin supportedProtocolString.

self typeInfoClassVariables: b mixin  classVariableString.
self typeInfoInstanceVariables: b mixin instanceVariableString.

self classSide protocols: b mixin classSide supportedProtocolString.
self classSide typeInfoInstanceVariables: b mixin classSide instanceVariableString!

conformToShape: b <ClassMirror>
"Private"
| clone <MixinVMMirror> |

self installed 
	ifTrue:["Clone myself,  make its shape conform to that of b, and install it in my place"
					clone := self cloneConformingToShape: b.
					"install clone "
					self install: clone 
							 ifFail:[:e <Str> | self error: 'Inconsistency when attempting to modify ', self name, ' ', e].
				]
	ifFalse:[self conform: self mixinDecl toShape: b].
!

convert: m <Mirror> ifFail: fb <[Str]>

m convertToMixin: self ifFail: fb.



!

convert: m <Mirror> toGeneric: g   <GenericMirror> ifFail: fb <[Str]>

self assert: [g body = self].
m convertToGenericMixin: g ifFail: fb.!

convertToGenericMixin: g <GenericMirror> ifFail: fb <[Str]>

self convertToMixin: g body ifFail: fb.
self nestInGenericWithTypeArguments: g typeArgumentString.
self adjustBounds.

!

convertToMixin: m <MixinDeclMirror> changingClass: oldClass <ClassMirror> to: newClass <ClassMirror> ifFail: fb <[Str, ^DoesNotMatter]>

| clone <MixinVMMirror> b <ClassMirror> |

self installed ifFalse:[self shouldNotHappen].
self isMeta
  ifFalse:[
                 m superclassTypeString isEmpty ifFalse:[self superclassType: m  superclassTypeString].
                 b := m body.
                 clone := self cloneConformingToShape: b.
                   "install clone " 
                self changeToMixin: clone 
                         oldClasses: (OrderedCollection[Class] new  add: oldClass reflectee; yourself)
                         newClasses: (OrderedCollection[ClassMirror] new add: newClass; yourself)
                         ifFail: [:e <Str> | self error: 'Inconsistency when attempting to modify ', self name].
                 self conformBodyTypeTo:  b.
                 ]
  ifTrue:[self instanceSide convertToMixin: m instanceSide changingClass: oldClass instanceSide to: newClass instanceSide ifFail: fb].!

convertToMixin: m <MixinDeclMirror> ifFail: fb <[Str]>

self isMeta
  ifFalse:[
                 m superclassTypeString isEmpty ifFalse:[self superclassType: m  superclassTypeString].
                 self body: m body.
                ]
  ifTrue:[self instanceSide convertToMixin: m instanceSide ifFail: fb].!

extensionsAreNotSubtypes

^self extensionsAreSubtypes: false!

extensionsAreSubtypes ^ <Boolean>

^(self sourceInfo extensionsAreSubtypesString  = #false) not!

extensionsAreSubtypes: e <Boolean>

self typeInfo extensionsAreSubtypes: e.
self sourceInfo extensionsAreSubtypes: e.
!

formatFor: c <ClassVMMirror>   mixinFormat: mf <Symbol> formats: formats <VarDict[Class, Symbol]> ifFail: fb <[Str, ^DoesNotMatter]> ^ <Symbol>
"Private"
|  f  <Symbol> |

c isNil ifTrue: [^#Oops].
c format = #Special ifTrue:[^#Special]. "Magic things like blocks etc."
"Weak arrays are a special case.  We check if the weak array mixin is used, and if so check to see if
the superclass is Array. Other cases are banned"

c mixin reflectee = IndexedNextOfKinInstanceVariables
  ifTrue:[
                c superclass reflectee = Array ifFalse:[self error: 'Bad Magic for weak arrays'].
               ^#IndexedNextOfKinInstanceVariables
               ].
 

f := formats at: c reflectee ifAbsent:[c format].
f isNil ifTrue:[                         
                         f := self combinedFormatOfMixinFormat: mf  
                                         andSuperclassFormat: (self formatFor: c superclass mixinFormat: mf formats: formats ifFail: fb) ifFail: fb.
                          formats at: c reflectee put: f
                          ].
^f

            !

formatsOf: cs <Cltn[Class]> mixinFormat: mixinFormat <Symbol> ifFail: fb <[Str, ^DoesNotMatter]> ^ <VarDict[Class, Symbol]>

| 
j  <Integer>
formats <VarDict[Class, Symbol]>
dm <ClassVMMirror>
|

formats := IdentityDictionary[Class, Symbol] new: cs size.
cs do:[:d <Class> | formats at: d put: nil].
cs do:[: d <Class> | 
			dm := ClassVMMirror on: d.
			(self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb). " new format, if legal !!"
			].
^formats!

handleInterfaceChangeFrom: oldAST  <MethodDecl>  to: newAST  <MethodDecl>
"Private"
"Check if interface has changed, and take appropriate action"
| 
nsig <MsgSignature> 
osig <MsgSignature> 
sub <Boolean> 
sup <Boolean> 
typeInfo <SideUpdate>
|

"compare old and new signatures to determine interface change."
nsig := newAST type.
osig := oldAST type.
typeInfo := self typeInfo .

typeInfo setupTypeAssumptions.
DeltaSilentTypeErrorHandler new catchErrorsFor: [		"Only the result is relevant, not potential errors since they cannot be reported in a meaningful way anyway"
	sub := nsig subtypeOf: osig assuming: DeltaGlobalTrail.
	sup := osig subtypeOf: nsig assuming: DeltaGlobalTrail.
].
 typeInfo  retractTypeAssumptions.

(sub and:[sup]) ifTrue:[^self].
sub ifTrue:[^self heirsCheckSelector: newAST selector withSignature: nsig].
self noteFilteredSendersOf: newAST selector.
sup ifTrue:[
                     self nonSubtypeHeirsCheckSelector: newAST selector withSignature: nsig.
                    "test structural assumptions?"
                     ]
      ifFalse:[self heirsCheckSelector: newAST selector withSignature: nsig].!

hasSelector: selector <Symbol> ^ <Boolean>

	self compiledMethodAt: selector ifFail: [ ^false ].		"We use compiled methods here since otherwise type info will have to be loaded"
	^true!

heir: ih <Decl> checkSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check heir ih to see whether it conflicts typewise with the signature sig of selector sel"
| ihSig <MsgSignature> typeInfo <SideUpdate>  ihTypeInfo <MixinInvocationSide> |

ihTypeInfo := Type forMixin: ih mixin reflectee.
typeInfo := self typeInfo .

(ihTypeInfo functions includesKey: sel)
       ifTrue:[
                     typeInfo errorHandler pushDefinitions: ihTypeInfo and: typeInfo.
                     typeInfo errorHandler pushSelector: sel.
                     ihSig := (ihTypeInfo functions at: sel) type.
                     ihTypeInfo subtype
                           ifTrue:[ "need to set and retract type assumptions"
                                        ihTypeInfo setupTypeAssumptions.                          
                                        (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                 ifFalse:[ typeInfo reportError: DeltaMsgConflictSubtypeInSubError new.].
                                          ihTypeInfo retractTypeAssumptions.
                                          ]
                             ifFalse:[
                                            (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                      ifFalse:[ typeInfo reportError: DeltaMsgConflictInheritedtypeInSubError new.].
                                            ].
                           typeInfo errorHandler popDefinitions.
                           typeInfo errorHandler popSelector.     
                          ].
!

heirScope  ^ <Scope>

"delete"
self deltaHack.

^(DeltaOverrideScope new base: self superclass heirScope;
                                                     delta: self localScope; yourself)
!

heirsCheckSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check all heirs to see whether they conflict typewise with the signature sig of selector sel"

self immediateHeirs do:[:ih <Decl> |
                                               self heir: ih checkSelector: sel withSignature: sig
                                              ].!

immediateHeirs  ^ <OrdCltn[ClassMirror]>
	"Return a collection of immediate heirs for all invocations"
	| heirs  <OrdCltn[ClassMirror]> |
	heirs := OrderedCollection[ClassMirror] new.
	self invocations do: [ :inv <AbstractClassMirror> | heirs addAll: inv immediateHeirs ].
	^heirs!

inheritsFrom: aMixin <Mixin> ^ <Boolean>

	^self reflectee == aMixin!

initializeSuperclassType: s body: b

"self reflect: MixinVMMirror createNewMixin."
self superclassType: s.
self body: b.
!

insertMethod: src <Str> visibility: vis <Symbol> category: cat <Symbol> ifFail: blk <[Str]> ^ <ParseTree>
"Private"
"
This  method is used internally to add a method to a mixin. It is
factored out so that both the typechecking and non-typechecking versions
of adding a method can share almost all the code
"

| pt <ParseTree> method <Method> ast  <DeltaMethod> oldAST  <DeltaMethod> |

    pt := self parseMethod: src ifFail: blk.
    ast := pt body.
    ast visibility: vis.
	
	"Wrong. What about inherited stuff, or messages"
    oldAST := self hasFullTypeInfoLoaded
                                   ifTrue:[self typeInfo methods at: ast selector 
                                                            						ifAbsent:[self typeInfo messages at: ast selector 
                                                                                                                       						 ifAbsent:[nil] ] ].

	method := self compileMethod: ast ifFail: blk.
    self makeChange:[:mvm <MixinVMMirror> | mvm addMethod: method ifFail: blk]
        ifFail: blk.
	self hasFullTypeInfoLoaded ifTrue:[self typeInfo addMethod: ast].
	
	self sourceInfo source: src category: cat 	visibility: vis typeFormat: (ast type formattedName: pt) forSelector: ast selector.

	"ast timeSaved: Time dateAndTimeNow."
	"oldAST isNil ifFalse:[self changeMethod: oldAST to: ast.]."
	
	^pt
!

install

^self mixinDecl install!

install: mixin <MixinVMMirror> ifFail: fb <[Str, ^DoesNotMatter]> ^ <MixinDeclMirror>
"
Private.

This method installs mixin into the vm as my mixin."

^self changeToMixin: mixin 
         oldClasses: OrderedCollection[Class] new 
         newClasses: OrderedCollection[ClassMirror] new
         ifFail: fb
!

installed  ^ <Boolean>
"Private"

self invocationInfo invocations isEmpty
	ifTrue:[self uninstall].
^self mixinDecl installed!

instanceVariableAt: aName <Symbol> ifAbsent: aBlock <[]>

(self mixinDecl hasInstVarName: aName) ifFalse:[^aBlock value].
self instanceVariablesDo:[:v <VarDecl> | v name = aName ifTrue:[^v]].
^aBlock value.!

instanceVariableString ^ <Str>

^self sourceInfo instanceVariableString
!

instanceVariables: vars <Str>

| oldNames <Cltn[Symbol]> newNames <OrdCltn[Symbol]> newDecls <OrdCltn[VarDecl]> |

self deltaHack.
"We parse in a dummy scope since the parser insert the instvar decls in the scope and will complain about existing ones."
newDecls := (DeltaParser new parseInstVarList: vars within: (DeltaScope within: nil)) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: self scope].

self nonAtomic.
oldNames := OrderedCollection[Symbol] new.
self instanceVariablesDo: [ :v <VarDecl> | oldNames add: v name ].
newNames := newDecls collect: [: v <VarDecl> | v name].

self makeChange: [:mvm <MixinVMMirror> |
                                     mvm changeInstanceVariablesTo: newNames]
         ifFail: [:s <Str> | self error: s ].

"Now we have changed the mixin; we must adjust the type info"
"Remove old inst vars from the type info"
oldNames do: [ :name <Symbol> | 
	self typeInfoRemoveInstanceVariable: name ].

self sourceInfo instanceVariableString: vars.
newDecls do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].
"Reparse again to redeclare instvar decls. This should be changed shortly!!
DeltaParser new parseInstVarList: vars within: self scope."
!

instanceVariablesDo: blk  <[VarDecl]>

| typeInfo <SideUpdate> sorted |

typeInfo := self typeInfo.
self deltaHack.
sorted := SortedCollection[DeltaInstVar] new sortBlock: [:a <DeltaInstVar>  :b <DeltaInstVar> | a ordinalNumber <= b ordinalNumber].
typeInfo  instVarDecls do: [:v <DeltaInstVar> | sorted add: v].
sorted do: blk.
!

invocationInfo ^<AbstractInvocationData>

	^InvocationInfo at: self reflectee ifAbsent: [ self error: 'Inconsistency in invocation data' ].!

invocations  ^<Cltn[AbstractClassMirror]> 

	^self invocationInfo invocations collect: [ :class <Class> | AbstractClassMirror on: class ]
!

isAbstract ^ <Boolean>

^self sourceInfo abstractString  = #true!

isBranded ^ <Boolean>

^(self sourceInfo brandedString  = #false) not!

isMeta ^ <Boolean> 

^self reflectee isMeta!

isSubtype ^ <Boolean>

^(self sourceInfo subtypeString  = #false) not!

komment

"This class represents a mirror on a mixin declaration.

The mirror maintains an instance variable, mixinDecl, which is a low level mirror
(a MixinVMMirror) on the actual mixin. Changes are accomplished by forwarding
to this low level mirror. The actual mixin being reflected is also available thru mixinDecl.

Changes to the structure of the mixin are accomplished by creating an uninstalled copy
of the mixin, and performing the changes on it, and the installing the changes atomically
using the changed copy as a constructor which is passed to the VM. The VM also receives
a list of all invocations and their dependent subclasses, so that it can modify them atomically
at the same time.

This process is done using the makeChange:ifFail: method, which in turn invokes the
install:ifFail: method.

Methods are simply added to the mixin, and copied down to invocations. This is not done atomically
at this point.
"!

localScope  ^ <Scope>

"delete"
self deltaHack.

^DeltaScope new on: self !

makeChange: changeBlock <[MixinVMMirror, ^MixinVMMirror]> ifFail: fb <[Str]>

| copy <MixinVMMirror> |

self installed
  ifTrue:[
               copy := changeBlock value: (MixinVMMirror onCopyOf: self reflectee).
                self install: copy ifFail: fb "install copy"
                ]
  ifFalse:[changeBlock value: (MixinVMMirror on: self reflectee)]!

masterInvocation  ^<Class> 

	^self mixinDecl masterInvocation!

masterInvocation: c  <Class>  ifFail: fb <[Str]>

self isMeta ifTrue:[self error: 'Should not be called on meta side'].
self invocationInfo invocations size = 1 ifFalse: [^fb value: 'More than one master invocation'].		"The invocations should contain cm as the only element"
self invocationInfo invocations first  == c ifFalse: [^fb value: 'Master invocations not identical'].
self mixinDecl masterInvocation: c ifFail: fb.


!

methodAt: selector <Symbol> ifFail: blk   <[^X def]> ^ <DeltaMethod | X>

self methodsDo: [:m <DeltaMethod> | m selector = selector ifTrue: [^m]].
^blk value
!

methodsDo: blk  <[DeltaMethod]>

| typeInfo <SideUpdate> |

typeInfo := self typeInfo .
typeInfo  methods do: blk.
typeInfo messages do: blk.!

methodsFor: category <String>
    ^DefinitionReader for: self category: category
!

mixin ^ <MixinMirror>

	^self!

mixinDecl  ^ <MixinVMMirror>

^mixinDecl!

mixinDecl: md <MixinVMMirror>

"self assert:[md isKindOf: MixinVMMirror]."
mixinDecl := md!

nameExisting: n <Symbol> ifFail: fb <[Str]>

self nonAtomic.
self mixinDecl name: n ifFail: fb.
(Mirror on: (self priorReflecteeFor: n)) convertToMixin: self ifFail: fb.
                          !

nameNew: n <Symbol> ifFail: fb <[Str]>

"Must check if n exists already. If so, we must update it to reflect the
state of this mixin.
"
self setName: n ifFail: fb.
self install.
Delta at: n put: self reflectee.
      !

nestInGenericWithTypeArguments: tas  <Str>

super nestInGenericWithTypeArguments: tas.
self isMeta ifFalse:[self sourceInfo typeArgumentString: tas].!

nonSubtypeHeir: ih <Decl> checkSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check heir ih to see whether it conflicts typewise with the signature sig of selector sel"
| ihSig <MsgSignature>  typeInfo <SideUpdate>  ihTypeInfo <MixinInvocationSide> |


ihTypeInfo := Type forClass: ih reflectee.
typeInfo := self typeInfo .

(ihTypeInfo functions includesKey: sel)
       ifTrue:[
                      typeInfo errorHandler pushDefinitions: ihTypeInfo and: typeInfo.
                      typeInfo errorHandler pushSelector: sel.
                     ihSig := (ihTypeInfo functions at: sel) type.
                     ihTypeInfo  subtype
                             ifFalse:[
                                            (ihSig subtypeOf: sig assuming: DeltaGlobalTrail)
                                                      ifFalse:[ typeInfo reportError: DeltaMsgConflictInheritedtypeInSubError new.].
                                            ].
                           typeInfo errorHandler popDefinitions.
                           typeInfo errorHandler popSelector.     
                          ].
!

nonSubtypeHeirsCheckSelector: sel <Symbol> withSignature: sig  <MsgSignature>

"Private.
Check all heirs that are inherited types of me to see whether they conflict typewise with the siganture sig of the
selector sel"

self immediateHeirs do:[:ih <Decl> |
                                               self nonSubtypeHeir: ih checkSelector: sel withSignature: sig
                                               ].!

notSubtype

self subtype: false!

noteFilteredSendersOf: sel <Symbol>

" Private.
This method is intended to make a note of all potentially problematic
senders of the message sel.  Collect all senders, and filter
them according to a suitable criterion. Then add these to the set of
methods that may require typechecking."

| unfilteredSenders  <Set[MethodLocator]>  senders  <Set[MethodLocator]>  |

unfilteredSenders := self sendersOf:  sel.
"Here is where we supposedly filter out irrelevant sends. Currently we just select those 
methods that had successfully typechecked  "

senders := unfilteredSenders select:[:s | s deltaMethod  typecheckedSuccessfully].
 "add all relevant senders to the list of methods that must be re-typechecked"
senders do:[: sender  <MethodLocator>  | DeltaMethodsToRevisit add: sender.].
  





!

parseMethod: src <Str> ifFail: blk <[Str,Int]> ^ <ParseTree[DeltaMethod]>

	| scope <Scope> mi <Class> |
	"We use a constructed untyped scope if no type information is loaded.
		This is currently only enabled for mixins with a master invocation (since 
		currently computing the superclass type class object for a pure mixin will 
		cause type information to be loaded)."
	scope := (self hasTypeInfoLoaded or: [ (mi := self masterInvocation) isNil])
		ifTrue: [		self scope ]
		ifFalse: [	DeltaUntypedClassScope for: (AbstractClassMirror on: mi) ].
	^DeltaParser new parseMethod: src within: scope ifError: blk
!

poolString ^ <Str>

^self sourceInfo poolString!

pools: pools  <Str> 

self assert: [ pools isString ].
self changePoolsTo: ((DeltaParser new parseIdList: pools within: DeltaGlobals) collect: [ :pt <ParseTree[Ref]> | pt body])!

prepareInvocation2: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a!

prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a!

privateMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
!

protocols: p  <Str> 

self supportedProtocol: p!

publicMethodsFor: category <String>

	"For compatability"
    ^self methodsFor: category
!

recompileAllMethodsIfFail: blk <[]>

	self compiledMethodsDo: [ :method <Method> |
		self recompileMethod: method selector ifFail: blk ]!

recompileMethod: selector <Symbol> ifFail: blk <[]>

	| src <Str> method <Method> ast  <DeltaMethod> |

	src := self sourceForSelector: selector.
	ast := (self parseMethod: src ifFail: blk) body.
	method := self compileMethod: ast ifFail: blk.
	self makeChange:[:mvm <MixinVMMirror> | mvm addMethod: method ifFail: [^blk value]]
		ifFail: [self error: 'Failed attempt to install method in mixin ', self name].
!

referencesToAssociation: assoc <Association> ^ <Cltn[MethodLocator]>
	| result <Cltn[MethodLocator]> |
	result := OrderedCollection [MethodLocator] new.
	self mixinDecl methodsDo: [ :method <Method> | 
		 (method referencesAssociation: assoc) ifTrue: [
				result add: (MethodLocator new definition: self basicLocator selector: method selector)]].
	^result!

reflect: r  <MixinVMMirror>
"Private"

| i <InvocationData> ci <MetaInvocationData> |
self mixinDecl: r.
(InvocationInfo includesKey: r reflectee) ifFalse: [
	i := InvocationData new.
	InvocationInfo at: r reflectee put: i.
	(InvocationInfo includesKey: r classSide reflectee) ifFalse: [
		ci := MetaInvocationData new dual: i.
		InvocationInfo at: r classSide reflectee put: ci ] ]
!

reflectee  ^ <Mixin>

	^self mixinDecl isNil
		ifTrue: [		nil ]
		ifFalse: [	self mixinDecl reflectee ]!

reflectee: r <Mixin>

	self mixinDecl reflectee: r!

removeAllClassVariables
"We need to create the collection of names first, because we cannot iterate over the same
collection we are modifying "
| names <OrdCltn[Symbol]> |

names := OrderedCollection[Symbol] new.
self mixinDecl classVarNamesDo: [: n <Symbol> | names add: n].
names do:
   [: n <Symbol> | 
   self removeClassVariable: n 
            ifAbsent:[self error: 'Internal inconsistency - missing class variable in ', self name]
   ].
!

removeAllInstanceVariables

"We need to create the collection of names first, because we cannot iterate over the same
collection we are modifying "
| names <OrdCltn[Symbol]> |

names := OrderedCollection[Symbol] new.
self mixinDecl instVarNamesDo: [: n <Symbol> | names add: n].
names do:
   [: n <Symbol> | 
   self removeInstanceVariable: n 
            ifAbsent:[self error: 'Internal inconsistency - missing instance variable in ', self name]
   ].
!

removeClassVariable: name  <Symbol>  ifAbsent: blk  <[]> 

self isMeta ifTrue:[self error: 'Class variables cannot be manipulated through metaclasses'].
self makeChange:[:mvm <MixinVMMirror> | mvm removeClassVarName: name ifFail: [: e <Str> | blk value]]
        ifFail: [:e <Str> | self error: 'Failed attempt to remove class variable ', name, ' in mixin ', self name, ' : ', e].

self typeInfoRemoveClassVariable: name.!

removeClassVariable: name  <Symbol>  ifFail: blk  <[Str]> 

self isMeta ifTrue:[blk value].
self makeChange:[:mvm <MixinVMMirror> | mvm removeClassVarName: name ifFail: blk]
        ifFail: blk.

self typeInfoRemoveClassVariable: name.!

removeDefinitionIfFail: blk <[]>

	"Remove entry from system dictionary and source database"

	super removeDefinitionIfFail: [ ^blk value ].
	self mixinDecl: nil.
	^nil!

removeInstanceVariable: name  <Symbol>  ifAbsent: blk  <[]> 

self makeChange:[:mvm <MixinVMMirror> | mvm removeInstVarName: name ifFail: [: e <Str> | blk value]]
        ifFail: [:e <Str> | self error: 'Failed attempt to remove instance variable ', name, ' in mixin ', self name, ' : ', e].

self typeInfoRemoveInstanceVariable: name.!

removeMethod: selector <Symbol>  ifAbsent: blk <[]>

| typeInfo <SideUpdate> |

self mayNeedToUnwind.

(self hasSelector: selector)
	ifFalse: [	self sourceInfo removeSelector: selector ifAbsent: [].		"Remove if present in source database (for consistency)"
						^blk value ].
						
self makeChange:[:mvm <MixinVMMirror> | mvm removeMethodAt: selector ifFail: [:e <Str> | ^blk value ]] 
         ifFail: [:e <Str> | 'Failed attempt to remove method ', selector, ' in mixin ', self name, ' : ', e].

self hasFullTypeInfoLoaded
	ifTrue:[
				typeInfo := self typeInfo.
				typeInfo  methods removeKey: selector 
                                 				    ifAbsent:[typeInfo messages removeKey: selector
                                                                                    			            ifAbsent: []. "Should never happen"
                                                     				  ].	
				].
self sourceInfo removeSelector: selector ifAbsent: blk.!

removePool: name <Str>  ifAbsent: blk <[]>

self deltaHack.
self halt.!

rename: oldId <Symbol> to: newId <Symbol>

| s <ReadString> src <ReadString>  |

"rename in all methods"
self methodsDo:[: m <DeltaMethod> |
									src := self sourceForSelector: m selector.
									s := self rename: oldId to: newId in: src.
									s == src
										ifFalse:[self addMethod: s
																visibility: (self sourceInfo visibilityForSelector: m selector)
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
"rename in all instance variables"
s := self rename: oldId to: newId in: (src := self instanceVariableString).
s == src  ifFalse:[self instanceVariables: s].
"rename in supported protocol"
s := self rename: oldId to: newId in: (src := self supportedProtocolString).
s == src ifFalse:[self supportedProtocol: s].
"If non meta: "
self isMeta
	ifFalse:[
				"rename in superclass type"
					s := self rename: oldId to: newId in: (src := self superclassTypeString).
					s == src ifFalse:[self superclassType: s].
				"rename in all class variables"
					s := self rename: oldId to: newId in: (src := self classVariableString).
					s == src ifFalse:[self classVariables: s].
				"rename in all type arguments, if any"
					s := self rename: oldId to: newId in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide rename: oldId to: newId.
				].
!

renameGroup: grp <Dict[Symbol,Symbol]>

| s <ReadString> src <ReadString>  |

"rename in all methods"
self methodsDo:[: m <DeltaMethod> |
									src := self sourceForSelector: m selector.
									s := self renameGroup: grp in: src.
									s == src
										ifFalse:[self addMethod: s
																visibility: (self sourceInfo visibilityForSelector: m selector)
																category: (self sourceInfo categoryForSelector: m selector)
																ifFail:[:msg <Str>  :i <Int>  | self error: 'Renamed code uparseable: ', msg].
														].
								].
"rename in all instance variables"
s := self renameGroup: grp in: (src := self instanceVariableString).
s == src  ifFalse:[self instanceVariables: s].
"rename in supported protocol"
s := self renameGroup: grp in: (src := self supportedProtocolString).
s == src ifFalse:[self supportedProtocol: s].
"If non meta: "
self isMeta
	ifFalse:[
				"rename in superclass type"
					s := self renameGroup: grp in: (src := self superclassTypeString).
					s == src ifFalse:[self superclassType: s].
				"rename in all class variables"
					s := self renameGroup: grp in: (src := self classVariableString).
					s == src ifFalse:[self classVariables: s].
				"rename in all type arguments, if any"
					s := self renameGroup: grp in: (src := self typeArgumentString).
					s == src ifFalse:[self nestInGenericWithTypeArguments: s].
					self classSide renameGroup: grp.
				].
!

scope  ^ <Scope>

	^self typeInfo scope
!

scope: s <Scope>

	self typeInfo scope: s
!

selectorsFor: cat <Str> ^ <OrdCltn[Symbol]>
	
	^self sourceInfo selectorsFor: cat!

selectorsMatching: pattern <Str> ^ <Set[Symbol]>

	| result <Set[Symbol]> |
	result := Set[Symbol] new.
	self compiledMethodsDo: [ :method <Method> | 		"We use compiled methods here since otherwise type info will have to be loaded"
		(pattern platformMatch: method selector) 
			ifTrue: [	result add: method selector ] ].
	^result!

setName: n <Symbol> ifFail: fb <[Str]>

self mixinDecl name: n ifFail: fb.
self sourceInfo setName: n!

sourceForSelector: sel <Symbol>  ^ <Str>

	^self sourceInfo sourceForSelector: sel
!

sourceInfo ^<MixinSourceHandler>

	sourceInfo isNil 
		ifTrue: [ sourceInfo := MixinSourceHandler for: self ].
	^sourceInfo!

subtype ^ <Boolean>

	^self typeInfo subtype!

subtype: s <Boolean>

	self typeInfo subtype: s.
	self sourceInfo subtype: s.
!

superclassType ^ <ClassNode>

^self typeInfo superclassType.
!

superclassType: st <Str>

| superclass <ClassExpr> |

self assert: [ st isString ].
self sourceInfo superclassTypeString: st.
superclass := (DeltaParser new parseClassOrMixinExpr: st within: self scope) body.
self typeInfo superclassType: superclass.
(Type forMixin: self classSide reflectee) superclassType: superclass dualClassType.
AbstractClassMirror flushSubclassHierarchyCache.
!

superclassTypeString ^ <Str>

^self sourceInfo superclassTypeString
!

supportedProtocol: p <Str>

self assert: [ p isString ].
self sourceInfo supportedProtocolString: p.
p isEmpty ifFalse:[self typeInfo supportedProtocol: (DeltaParser new
parseTypeExpr: p within: self scope superScope) body]
                    ifTrue:[self typeInfo supportedProtocol: nil].!

supportedProtocolString ^ <Str>

^self sourceInfo supportedProtocolString
!

typeArgumentString ^ <Str>

^self isMeta ifTrue:[self instanceSide typeArgumentString]
                        ifFalse:[self sourceInfo typeArgumentString].
!

typeForNode: n <ASTNode> inMethod: m <Method > ^ <ObjectType>

^self typeInfo typeForNode: n inMethod: m!

typeInfo ^ <SideUpdate>
"Private"

^(Type forMixin: self reflectee)!

typeInfoAddClassVariable: v  <VarDecl>
"Private"

self isMeta ifFalse:[self classSide scope at: v name put: v.].
self typeInfo scope at: v name put: v.!

typeInfoAddInstanceVariable: v  <VarDecl>
"Private"

self typeInfo scope at: v name put: v.!

typeInfoClassVariables: vars <Str>
"Change class vars in type info and source only"
self deltaHack.
self assert: [ vars isString ].
self sourceInfo classVariableString: vars.
self classVariablesDo: [: v <VarDecl> | self typeInfoRemoveClassVariable: v name].
 ((DeltaParser new parseClassVarList: vars within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body  scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

!

typeInfoInstanceVariables: vars <Str>
"Change inst vars in type info and source only"
self deltaHack. 
self assert: [ vars isString ].
self sourceInfo instanceVariableString: vars.
self instanceVariablesDo: [: v <VarDecl> | self typeInfoRemoveInstanceVariable: v name].
 ((DeltaParser new parseInstVarList: vars within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

!

typeInfoRemoveClassVariable: name  <Symbol> 
"Private"

self isMeta ifFalse:[self classSide scope removeKey: name.].
self typeInfo scope removeKey: name.!

typeInfoRemoveInstanceVariable: name  <Symbol> 
"Private"
self typeInfo scope removeKey: name.!

typeNameForNode: n <ASTNode> inMethod: m <Method > ^ <String>

^self typeInfo typeNameForNode: n inMethod: m!

unbranded

self branded: false!

uninstall

^self mixinDecl uninstall!

updateDependenciesFrom: oldAST to: newAST

" Private.
Update the top level dependency graph based upon the differences among the new and old ASTs"
| newRefs <OrdCltn[Symbol]> oldRefs <OrdCltn[Symbol]> |
"add dependencies present in newAST"

newRefs := (DeltaReferenceGatherer new initialize methodNode: newAST) references.
newRefs do:[:r <Symbol> | DeltaDependencyGraph addDependencyFrom: self  name to: r].

oldRefs := (DeltaReferenceGatherer new initialize methodNode: oldAST) references.
oldRefs do:[:r <Symbol> | DeltaDependencyGraph removeDependencyFrom: self  name to: r].
"remove dependencies present in oldAST"
!

vmInvocations ^ <OrdCltn[ClassVMMirror]>
"Private"
	^self invocationInfo invocations collect:[: inv <Class> | ClassVMMirror on: inv]
!

|> c <ClassMirror > ^ <ClassMirror>
"h2"
| invocation <ClassVMMirror> |

self isMeta ifTrue:[self error: 'MetaMixins should not be invoked'].

invocation := ClassVMMirror createInvocationOf: self mixinDecl 
                              superclass:  (ClassVMMirror on: c reflectee)
                              ifFail: [: e | self error: 'Internal inconsistency in MixinDeclMirror>>|> ', e].
self class addTypeStructureForInvocation: invocation.
self addInvocation: invocation reflectee.

^InvocationMirror on: invocation reflectee
! !

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'accessing' !


shortDescription ^ <Str>

	"Returns a short desciption of this mixin"
	
	| header <String> |
	header := ''.
	self isGeneric
		ifTrue: [ 		header := header, 'generic ' ].
	self isSubtype
		ifFalse: [ 	header := header, 'non-subtype ' ].
	self isAbstract
		ifTrue: [		header := header, 'abstract ' ].
	header := header, 'mixin on ', self superclassTypeString.
	^header at: 1 put: (header at: 1) asUppercase; yourself
! !

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'loading type info' !


createMethodTypeStructure

	| 
	ast <DeltaMethod> 
	ti <DeltaSideUpdate>
	selector <Symbol>
	methods <IdentitySet[Symbol]> 
	messages <IdentitySet[Symbol]>
	 |

ti := self typeInfo.
methods := IdentityDictionary[Symbol, DeltaMethod] new.
messages := IdentityDictionary[Symbol, DeltaMethod] new.
ti 	methods: methods;
	messages: messages.
self compiledMethodsDo:
[: m <Method> | 
		selector := m selector.
		m isAbstract
			ifTrue: [		messages at: selector put: (LazyMessage new mixin: self reflectee; mySelector: selector)]
			ifFalse: [	methods at: selector put: (LazyMethod new mixin: self reflectee; mySelector: selector)] 
]
!

createTypeStructure
" This method creates type information for my mixin, based upon the contents of
the  source database"
|
cDecl  <ClassUpdate> 
mixinTypeInfo <SideUpdate>
classMixinTypeInfo <SideUpdate>
st <ClassId | MixinInvocationNode | GenericApplicationClassType>
classSide <MixinDeclMirror>
isGeneric <Boolean>
sp <Str>
sts <Str>
tas <VarOrdCltn[TypeFormal]>
 |

self isMeta ifTrue:[^self instanceSide createTypeStructure].
ReportTypeLoading
	ifTrue:[ Platform errorStream show: 'Loading type info for ', self name; cr].
self name = #Object ifTrue:[^self createTypeStructureForObject].
classSide := self classSide.
isGeneric := self sourceInfo isGeneric.

"Create type info node(s)"

cDecl := DeltaClassUpdate new  abstract: self isAbstract; 
                                                       branded: self isBranded; 
                                                       monotonic: self extensionsAreSubtypes; 
                                                       subtype: self isSubtype.
mixinTypeInfo :=  DeltaSideUpdate new initialize.
cDecl instanceSide: mixinTypeInfo.
classMixinTypeInfo :=  DeltaSideUpdate new initialize classDecl: cDecl.
"Nil out methods to provoke reparsing"
mixinTypeInfo methods: nil; messages: nil.
classMixinTypeInfo  methods: nil; messages: nil.

cDecl instanceSide: mixinTypeInfo.

Type atMixin: self reflectee put: mixinTypeInfo.
Type atMixin: self classSide  reflectee put: classMixinTypeInfo.

DeltaSilentTypeErrorHandler new catchErrorsFor: [
isGeneric
   ifTrue:[ 
                tas := (DeltaParser new parseTypeArgs: self typeArgumentString
                                                              within:  DeltaGlobals
                                                              ifError:[:m <Str> : i <Integer> | self error: 'Source database contains invalid code'])
                              collect: [ :pt <ParseTree> | pt body].
               mixinTypeInfo := DeltaGenericSideUpdate new name: self name  body: mixinTypeInfo formals: tas.
               classMixinTypeInfo := DeltaGenericSideUpdate new name: classSide name body: classMixinTypeInfo formals: tas.
              Type atMixin: self reflectee put: mixinTypeInfo.
              Type atMixin: self classSide  reflectee put: classMixinTypeInfo.
              self adjustBounds.
               ].

"set up superclass type info "
sts := self superclassTypeString.
sts isEmpty ifTrue:[sts := 'Object'].
st := (DeltaParser new parseClassOrMixinExpr:  sts within: self scope superScope) body.

mixinTypeInfo superclassType:  st.
classMixinTypeInfo superclassType: st dualClassType.

"Patch up instance, class and pool variables for both sides"

 ((DeltaParser new parseInstVarList: self instanceVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

 ((DeltaParser new parseClassVarList: self classVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

 ((DeltaParser new parseInstVarList:  classSide instanceVariableString within:  classSide scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> |  classSide typeInfoAddInstanceVariable: v].

"self  typeInfoPools: self poolString."

" patch up supported protocol info on both sides"

sp := self supportedProtocolString.
sp isEmpty 
	ifFalse:[mixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr: sp 
                                                                    within: self scope superScope) body.
					isGeneric ifTrue:[mixinTypeInfo formals do:[:f <TypeFormal>  | mixinTypeInfo supportedProtocol addRelevantTypeVar: f typeVar]].
                   ].

sp :=  self classSide supportedProtocolString.

sp isEmpty 
	ifFalse:[classMixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr:  sp 
                                                                               within:  classSide scope superScope) body.
 					isGeneric ifTrue:[classMixinTypeInfo formals do:[:f <TypeFormal>  | 
 																													classMixinTypeInfo supportedProtocol addRelevantTypeVar: f typeVar
 																													]
 													].
                   ].
                   ].
!

createTypeStructureForObject

"Private"
"Special case, when reflectee is Object. Requires special type structure"

|
cDecl  <ClassUpdate> 
mixinTypeInfo <SideUpdate>
classMixinTypeInfo <SideUpdate>
st <ClassId | MixinInvocationNode | GenericApplicationClassType>
classSide <MixinDeclMirror>
sp <Str>
sts <Str>
|

classSide := self classSide.


"Create type info node(s)"

cDecl := DeltaClassUpdate new  abstract: self isAbstract; 
                                                       branded: self isBranded; 
                                                       monotonic: self extensionsAreSubtypes; 
                                                       subtype: self isSubtype.
mixinTypeInfo :=  DeltaSide new initialize.
classMixinTypeInfo :=  DeltaObjectClassSide new initialize classDecl: cDecl.
"Nil out methods to provoke reparsing"
mixinTypeInfo methods: nil; messages: nil.
classMixinTypeInfo methods: nil; messages: nil.

cDecl instanceSide: mixinTypeInfo.

Type atMixin: self reflectee put: mixinTypeInfo.
Type atMixin: self classSide  reflectee put: classMixinTypeInfo.

classMixinTypeInfo superclassType: (DeltaClassId new setId: #Class; scope: DeltaGlobals).


"Patch up instance, class and pool variables for both sides"

 ((DeltaParser new parseInstVarList: self instanceVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> | self typeInfoAddInstanceVariable: v].

 ((DeltaParser new parseClassVarList: self classVariableString within: self scope) collect: [ :pt <ParseTree[VarDecl]> | pt body scope: DeltaGlobals])
   do:[:v <VarDecl> | self typeInfoAddClassVariable: v].

 ((DeltaParser new parseInstVarList:  classSide instanceVariableString within:  classSide scope) collect: [ :pt <ParseTree[VarDecl]> | pt body])
   do:[:v <VarDecl> |  classSide typeInfoAddInstanceVariable: v].

"self  typeInfoPools: self poolString."

" patch up supported protocol info on both sides"

sp := self supportedProtocolString.
sp isEmpty ifFalse:[mixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr: sp 
                                                                    within: self scope superScope) body.].

sp :=  self classSide supportedProtocolString.

sp isEmpty ifFalse:[classMixinTypeInfo supportedProtocol: (DeltaParser new parseTypeExpr:  sp 
                                                                               within:  classSide scope superScope) body.].




!

hasFullTypeInfoLoaded ^ <Boolean>

^self hasTypeInfoLoaded and:[self typeInfo hasMethodsLoaded].!

loadMsgSelector: sel <Symbol> ^ <DeltaMethod>

| ast <DeltaMethod> |
	ReportTypeLoading
		ifTrue:[Platform errorStream  show: 'Loading type info for message ', self name, '>>', sel; cr].
   ast := (DeltaParser new parseMethodHeader: (self sourceForSelector:  sel)
                                                  within: self scope
                                                  ifError: [self error: 'Internal failure: Source database has syntax errors']
                                                         ) body.
    ast visibility: (self sourceInfo visibilityForSelector: sel).
    self typeInfo messages at: sel put: ast.
    ast clearBody.
    ^ast!

loadSelector: sel <Symbol> ^ <DeltaMethod>

| ast <DeltaMethod> |

	ReportTypeLoading
		ifTrue:[Platform errorStream show: 'Loading type info for method ', self name, '>>', sel; cr].
   ast := (DeltaParser new parseMethodHeader: (self sourceForSelector:  sel)
                                                  within: self scope
                                                  ifError: [: e <Str> :i <Int> | self error: 'Internal failure: Source database has syntax errors']
                                                         ) body.
    ast visibility: (self sourceInfo visibilityForSelector: sel).
    self typeInfo methods at: sel put: ast.
    ast clearBody.
    ^ast! !

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'typechecking' !


typecheck

	| methodsWithoutBody <OrdCltn[DeltaMethod]> tmp <DeltaMethod> |

	methodsWithoutBody := OrderedCollection[DeltaMethod] new.
	self methodsDo: [ :m <DeltaMethod> | m body isNil ifTrue: [ methodsWithoutBody add: m ]].
	[
		methodsWithoutBody do: [ :m <DeltaMethod> |
			DeltaSilentTypeErrorHandler new catchErrorsFor: [
				tmp := (self parseMethod: (self sourceForSelector: m selector) ifFail: [:s <Str> :i <Int> | self halt]) body
			].
               m type: tmp type.
			m body: tmp body
		].
		self typeInfo typecheck.
	] ensure: [
		methodsWithoutBody do: [ :m <DeltaMethod> | m clearBody ]
	]
!

typecheckClassVars

self typeInfo typecheckClassVarDecls 


!

typecheckDeclaration

self typeInfo typecheckDeclaration!

typecheckInstVars

self typeInfo typecheckInstVarDecls 
!

typecheckInterface

self typeInfo typecheckInterface!

typecheckSelector: sel <Symbol>

	| m <DeltaMethod> tmp <DeltaMethod> methodHasBody <Boolean> |
	
	m := self methodAt: sel ifFail: [self error: 'Method not found'].
	methodHasBody := m body notNil.
	[
		methodHasBody
			ifFalse: [	DeltaSilentTypeErrorHandler new catchErrorsFor: [
									tmp := (self parseMethod: (self sourceForSelector: sel) ifFail: [:s <Str> :i <Int> | self shouldNotHappen]) body
								].
								m type: tmp type.
								m body: tmp body.
							].
		self typeInfo typecheckMethod: m.
	] ensure: [
		methodHasBody
			ifFalse: [	m clearBody ]
	]
!

typecheckSelectorInterface: sel <Symbol>

	| m <DeltaMethod> tmp <DeltaMethod> methodHasBody <Boolean> |
	
	m := self methodAt: sel ifFail: [self error: 'Method not found'].
	methodHasBody := m body notNil.
	[
		methodHasBody
			ifFalse: [	DeltaSilentTypeErrorHandler new catchErrorsFor: [
									tmp := (self parseMethod: (self sourceForSelector: sel) ifFail: [:s <Str> :i <Int> | self shouldNotHappen]) body
								].
								m body: tmp body.
							].
		self typeInfo typecheckMethodInterface: m.
	] ensure: [
		methodHasBody
			ifFalse: [	m clearBody ]
	]
!

typecheckSuperclassClause

self typeInfo typecheckSuperclassType.
!

typecheckSupportedProtocol

self typeInfo typecheckSupportedProtocol. !

typecheckTypeArguments

self typeInfo asGeneric typecheckTypeArgs. 
! !


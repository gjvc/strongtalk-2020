Delta define: #DeltaLoop as: (
(Class subclassOf: 'DeltaExpression' instanceVariables: 'whileTrue prologue cond body ')) !

(Delta mirrorFor: #DeltaLoop) revision: '$Revision: 1.2 $'!

(Delta mirrorFor: #DeltaLoop) group: 'ast'!

(Delta mirrorFor: #DeltaLoop)
comment: 
'Generated by the rewriter.
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!

! (Delta mirrorFor: #DeltaLoop) methodsFor: 'Unclassified' !


apply: aTool
    aTool loopNode: self!

body
	^ body!

cond
    ^ cond!

do: n timesRepeat: block
	|
	scope	<DeltaCodeScope>
	name		<Symbol>
	var			<DeltaParameter>
	|
	scope := block body scope.

	"introduce counter variable"
	name := '.i' asSymbol.
	var := DeltaParameter new name: name type: (DeltaTypeId new setId: #Integer; scope: scope).	"type not important, but a node needs to be present"
	scope parameters add: var.
	scope at: name put: var ifThere: [ self halt ].

	"translate n timesRepeat: block  into 1 to: n do: block"
	self from: (DeltaInt new value: 1) to: n do: block!

from: beg to: end by: step do: block
	|
	blockScope		<DeltaCodeScope>	
	emptyOC				<OrdCltn[DeltaASTNode]>
	counter					<DeltaRef>
	limitNeeded		<Boolean>
	limitName			<Symbol>
	limitVar					<DeltaTemporary>
	limit							<DeltaLiteral | DeltaRef>
	condSel				<Symbol>
	condArg				<OrdCltn[DeltaExpression]>
	condExpr				<DeltaExpression>
	condBody			<DeltaCodeBody>
	condStats			<OrdCltn[DeltaStatement]>
	condScope			<DeltaCodeScope>
	incArg					<OrdCltn[DeltaExpression]>
	incExpr					<DeltaExpression>
	incStat					<DeltaStatement>
	prologueStats	<OrdCltn[DeltaStatement]>
	|
	"preliminaries"
	self assert: [ step isIntNode ].
	self assert: [ block isBlockNode ].
	blockScope := block body scope.
	emptyOC := OrderedCollection new.
	
	"loop counter (= block parameter)"
	counter := DeltaRef new decl: (blockScope parameters first).
	
	"introduce counter limit variable if needed"
	(limitNeeded := end isLiteralNode not)
		ifFalse: [
			"no limit variable needed - use end directly since there's no computation involved"
			limit := end
		]
		ifTrue: [
			limitName := '.limit' asSymbol.
			limitVar := DeltaTemporary new name: limitName type: (DeltaTypeId new setId: #Integer; scope: blockScope). "type not important, but a node needs to be present"
			blockScope temporaries add: limitVar.
			blockScope at: limitName put: limitVar ifThere: [ self halt ].
			limit := DeltaRef new decl: limitVar
		].
	
	"setup loop condition => introduce condition block for whileTrue: loop"
	condSel :=
		step value < 0
			ifTrue: [ #<= ]
			ifFalse: [ #>= ].
	condArg := OrderedCollection new add: counter ; yourself.
	condExpr := DeltaNormalSend new to: limit send: (DeltaMessage new send: condSel with: condArg).
	condStats := OrderedCollection new add: condExpr ; yourself.
	condScope := DeltaCodeScope within: blockScope superScope.
	condScope
		  parameters: emptyOC
		; temporaries: emptyOC
		; inline.
	condBody :=
		DeltaCodeBody new
			parameters: emptyOC
			temporaries: emptyOC
			statements: condStats
			scope: condScope.

	"add counter increment to loop body"
	incArg := OrderedCollection new add: counter ; yourself.
	incExpr := DeltaNormalSend new to: step send: (DeltaMessage new send: #+ with: incArg).
	incStat := DeltaAssignment new to: counter assign: incExpr.
	block body statements add: incStat.

	"setup prologue"
	prologueStats := OrderedCollection new.
	prologueStats add: (DeltaAssignment new to: counter assign: beg).
	limitNeeded ifTrue: [
		"initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects"
		prologueStats add: (DeltaAssignment new to: limit assign: end)
	].
	
	"initialize loop instance variables"
	prologue := prologueStats.
	cond := condBody.
	whileTrue := true.
	body := block body!

from: beg to: end do: block
	self from: beg to: end by: (DeltaInt new value: 1) do: block!

isLoopNode
    ^ true!

komment
    "Generated by the rewriter."!

prologue
	^ prologue!

repeat: block
    self assert: [block isBlockNode].
    cond := block body.
    cond statements add: (DeltaBool new value: true).
    whileTrue := true.
    body := nil

    "At some point this should be translated into a real endless loop,
    such that the special byte code 77h can be used for interpretation."!

while: val do: block
    self assert: [val isBoolean].
    self assert: [block isBlockNode].
    cond := block body.
    whileTrue := val.
    body := nil!

while: block1 is: val do: block2
    self assert: [block1 isBlockNode].
    self assert: [block2 isBlockNode].
    self assert: [val isBoolean].
    cond := block1 body.
    whileTrue := val.
    body := block2 body!

whileTrue
    ^ whileTrue! !


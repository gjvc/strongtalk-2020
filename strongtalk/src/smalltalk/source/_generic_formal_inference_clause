Class
#categories!
inferring!
private-accessing!
private! !
typeArgNumber:!
869652!
private-accessing!
1Integer:! !
#superclassTypeString!
DeltaASTNode! !
#group!
ast! !
inferFrom:!
867971!
inferring!
0InferenceSignature:ObjectType! !
#extensionsAreSubtypes!
true! !
#revision!
$Revision: 1.3 $! !
#instanceVariableString!
target <ObjectTypeInferenceClause>  typeArgNumber <Integer> genericId <Symbol>! !
genericId!
868793!
private-accessing!
1Symbol! !
target!
869126!
private-accessing!
1ObjectTypeInferenceClause! !
genericId:!
868955!
private-accessing!
1Symbol:! !
generic!
870111!
private!
1DeltaGeneric! !
#subtype!
true! !
#branded!
true! !
#comment!
I implement inference clauses like Cltn[X def].
In general,  an inference clause may have one of
two concrete syntactical forms:

(1) F[X1, ... Xk def, ... Xn]  
(2) typeArg n of generic F of ...

Both forms get represented internally as GenericFormalInference
clauses.
 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.! !
#abstract!
false! !
target:!
869301!
private-accessing!
1ObjectTypeInferenceClause:! !
allInvocationsOf:in:!
869818!
private!
1DeltaGeneric:Cltn[ObjectType]:Cltn[GenericApplicationType]! !
#supportedProtocolString!
ObjectTypeInferenceClause! !
typeArgNumber!
869481!
private-accessing!
1Integer! !
minimalTypeOf:ifNone:!
870362!
private!
1Cltn[GenericApplicationType]:[^DoesNotMatter]:GenericApplicationType! !

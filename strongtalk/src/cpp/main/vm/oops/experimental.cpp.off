
//
//
//
//


#include "vm/system/bits.hpp"
#include "Klass.hpp"
#include "sizes.hpp"


// -----------------------------------------------------------------------------

class TaggedPointer {
    public:
        operator*();
    protected:
    private:
        uintptr_t _address;
        uintptr_t _tags: 8;
};


// -----------------------------------------------------------------------------

template <typename T>
class tOopDescriptor {


    protected:

    public:
        // The _mark instance variable is here rather than in memOop (where it belongs) because many C++ compilers have trouble with empty objects (size 0),
        // i.e., give them nonzero length which messes up all the subclasses.

        // So, to be perfectly clear, not all oopDescriptor classes truly have a _mark word; only the ones below memOop do.
        //    markOop _mark;

    public:
        // Called during bootstrappingInProgress for computing vtbl values see (create_*Klass)
        tOopDescriptor();


        // tag checks
        int tag() const {
            return maskBits( int( this ), Tag_Mask );
        }


        bool_t is_smi() const {
            return tag() == Int_Tag;
        }


        bool_t is_mem() const {
            return tag() == Mem_Tag;
        }


        bool_t is_mark() const {
            return tag() == MARK_TAG;
        }


        // tag dispatchers (inlined in oop.inline.h)
        Klass * blueprint() const;

        KlassOop klass() const;

        smi_t identity_hash();

        // memory management
        oop scavenge();

        oop relocate();

        // generation testers (inlined in oop.inline.h)
        bool_t is_old() const;

        bool_t is_new() const;

        Generation * my_generation();

        // type test operations (inlined in oop.inline.h)
        bool_t is_double() const;

        bool_t is_block() const;

        bool_t is_byteArray() const;

        bool_t is_doubleByteArray() const;

        bool_t is_doubleValueArray() const;

        bool_t is_symbol() const;

        bool_t is_objArray() const;

        bool_t is_weakArray() const;

        bool_t is_klass() const;

        bool_t is_process() const;

        bool_t is_vframe() const;

        bool_t is_method() const;

        bool_t is_proxy() const;

        bool_t is_mixin() const;

        bool_t is_association() const;

        bool_t is_context() const;

        bool_t is_indexable() const;


        // Returns is the oop is the nil object
        bool_t is_nil() const {
            return this == nilObj;
        }


        // Primitives
        oop primitive_allocate( bool_t allow_scavenge = true, bool_t tenured = false );

        oop primitive_allocate_size( int size );

        oop shallow_copy( bool_t tenured );

        bool_t verify();


        // printing functions for VM debugging
        void print_on( ConsoleOutputStream * st );        // First level print
        void print_value_on( ConsoleOutputStream * st );  // Prints oop as <ClassName>(<objectID>).

        // printing on default output stream
        void print();

        void print_value();

        // return the print strings
        char * print_string();

        char * print_value_string();

        friend class memOopKlass;
};


class tMemOopDescriptor : public tOopDescriptor {

    protected:
        // instance variable
        // markOop _mark;			// see comment in oop.hpp
        KlassOop _klass_field;        // the receiver's class

    public:
        // returns the header size of a memOop
        static int header_size() {
            return sizeof( MemOopDescriptor ) / oopSize;
        }


        // field offsets for code generation
        static int mark_byte_offset() {
            return ( 0 * oopSize ) - Mem_Tag;
        }


        static int klass_byte_offset() {
            return ( 1 * oopSize ) - Mem_Tag;
        }


        // coercions
        friend memOop as_memOop( void * p );


        // conversion from memOop to memOopDescriptor*
        MemOopDescriptor * addr() const {
            MemOopDescriptor * address = reinterpret_cast<MemOopDescriptor *>( reinterpret_cast<uintptr_t>( this ) - Mem_Tag );
//            _console->print_cr( "this [%#lx], address [%#lx]", this, address );
            return address;
        }


        // Space operations, is_old/new work w/o conversion to memOopDescriptor*
        // since oop > pointer (Mem_Tag >= 0)!
        bool_t is_old() const {
            return ( const char * ) this >= Universe::old_gen._lowBoundary;
        }


        bool_t is_new() const {
            return ( const char * ) this < Universe::new_gen._highBoundary;
        }


        // mark accessors
        MarkOop mark() const {
            return addr()->_mark;
        }


        void set_mark( MarkOop m ) {
            addr()->_mark = m;
        }


        void set_mark( memOop p ) {
            set_mark( MarkOop( p ) );
        }


        void set_mark( oop * p ) {
            set_mark( MarkOop( p ) );
        }


        oop * klass_addr() const {
            return ( oop * ) &addr()->_klass_field;
        }


        void set_klass_field( KlassOop k, bool_t cs = true ) {
            // %optimization
            //   since klasses are tenured the store check can be avoided
            addr()->_klass_field = k;
        }


        KlassOop klass_field() const {
            return addr()->_klass_field;
        }


        Klass * blueprint() const {
            // %include-conflict "return klass_field()->klass_part();"
            // To avoid include problems the above code has be translated into:
            return ( Klass * ) ( ( ( const char * ) klass_field() ) + sizeof( MemOopDescriptor ) - Mem_Tag );
        }

        // mark operations

        // use this after a copy to get a new mark
        void init_mark() {
            set_mark( MarkOopDescriptor::tagged_prototype() );
        }


        void init_untagged_contents_mark() {
            set_mark( MarkOopDescriptor::untagged_prototype() );
        }


        void mark_as_dying() {
            set_mark( mark()->set_near_death() );
        }


        // Notification queue support
        bool_t is_queued() const {
            return mark()->is_queued();
        }


        void set_queued() {
            set_mark( mark()->set_queued() );
        }


        void clear_queued() {
            set_mark( mark()->clear_queued() );
        }


        // mark operations
        smi_t identity_hash();

        void set_identity_hash( smi_t );

        // memory operations
        oop scavenge();

        void follow_contents();

        // scavenge the header part (see oop_scavenge_contents)
        void scavenge_header();

        // scavenge the body [begin..[end
        void scavenge_body( int begin, int end );


        void scavenge_tenured_header() {
        }


        void scavenge_tenured_body( int begin, int end );

        // Scavenge all pointers in this object and return the oop size
        int scavenge_contents();

        // Scavenge all pointers in this object and return the oop size
        // has_new_pointers reports if the object has pointers to new Space.
        int scavenge_tenured_contents();

        // Copy this object to survivor Space and return the new address
        // (called by scavenge)
        oop copy_to_survivor_space();

        // MarkSweep support
        void follow_header();

        void follow_body( int begin, int end );

        // support for iterating through all oops of an object (see oop_oop_iterate).
        void oop_iterate_header( OopClosure * blk );

        void oop_iterate_body( OopClosure * blk, int begin, int end );

        // support for iterate the layout of an object (see oop_layout_iterate).
        void layout_iterate_header( ObjectLayoutClosure * blk );

        void layout_iterate_body( ObjectLayoutClosure * blk, int begin, int end );

        // support for initializing objects (see allocateObject[Size]).
        void initialize_header( bool_t has_untagged, KlassOop klass );

        void initialize_body( int begin, int end );

        bool_t verify();


        // forwarding operations
        bool_t is_forwarded() {
            return mark()->is_mem();
        }


        void forward_to( memOop p ) {
            st_assert( p->is_mem(), "forwarding to something that's not a memOop" );
            set_mark( p );
        }


        memOop forwardee() {
            return memOop( mark() );
        }


        // marking operations
        bool_t is_gc_marked() {
            return not( mark()->is_mark() and mark()->has_sentinel() );
        } // Changed from mark()->is_smi(), Lars

        //bool_t is_gc_marked()			{ return not mark()->has_sentinel(); } // Changed from mark()->is_smi(), Lars

        // GC operations (see discussion in Universe.cpp for rationale)
        void gc_store_size();            // Store object size in age field and remembered set
        int gc_retrieve_size();        // Retrieve object size from age field and remembered set

        // accessors
        oop * oops( int which = 0 ) {
            return &( ( oop * ) addr() )[ which ];
        }


        oop raw_at( int which ) {
            return *oops( which );
        }


        void raw_at_put( int which, oop contents, bool_t cs = true );

        // accessing instance variables
        bool_t is_within_instVar_bounds( int index );

        oop instVarAt( int index );

        oop instVarAtPut( int index, oop value );

        // iterators
        void oop_iterate( OopClosure * blk );

        void layout_iterate( ObjectLayoutClosure * blk );

        // Returns the oop size of this object
        int size() const;

        // printing operation
        void print_id_on( ConsoleOutputStream * st );

        void print_on( ConsoleOutputStream * st );

        // bootstrappingInProgress operations
        void bootstrap_object( Bootstrap * st );

        void bootstrap_header( Bootstrap * st );

        void bootstrap_body( Bootstrap * st, int h_size );

        friend class MemOopKlass;
};

//
//  (C) 1994 - 2021, The Strongtalk authors and contributors
//  Refer to the "COPYRIGHTS" file at the root of this source tree for complete licence and copyright terms
//

#pragma once

#include "vm/memory/allocation.hpp"
#include "vm/system/asserts.hpp"
#include "vm/code/ScopeDescriptor.hpp"
#include "vm/utilities/GrowableArray.hpp"



// UnpackClosure is used for iteration over a string of nameDescs with different pc values.

class UnpackClosure : public StackAllocatedObject {
public:
    virtual void nameDescAt( NameDescriptor *nameDesc, const char *pc ) = 0;
};


//
// NativeMethodScopes represent the compressed NativeMethod source-level debugging information generated by the ScopeDescriptorRecorder.
// Whenever debugging information is needed, it is uncompressed into ScopeDescriptor instances.
//
// Compression works mainly by putting all "large" data (e.g., oops) into an array and
// using small (8-bit) indices to refer to this array from the actual scope data structures.
//

#define FOR_EACH_SCOPE( SCOPES, VAR ) \
   for( ScopeDescriptor* VAR = SCOPES->getNext( nullptr ); VAR not_eq nullptr; VAR = SCOPES->getNext( VAR ) )


// Implements the compact version of NativeMethod scopes with byte codes, shared Oop array, and value array.

class NativeMethodScopes : public ValueObject {

private:
    std::int32_t           _nativeMethodOffset;   //
    std::uint16_t _length;               //
    std::uint16_t _oopsOffset;           // word offset to the oops array
    std::uint16_t _valueOffset;          // word offset to the value array
    std::uint16_t _pcsOffset;            // word offset to ProgramCounterDescriptor array
    std::int32_t           _dependentsEnd;        // size of dependents

private:
    static std::uint16_t pack_word_aligned( std::int32_t value ) {
        st_assert( value % BytesPerWord == 0, "value should be word aligned" );
        st_assert( value >> BytesPerWord <= nthMask( BitsPerByte * sizeof( std::uint16_t ) ), "value exceeds limit" );
        return value >> LogBytesPerWord;
    }


    static std::int32_t unpack_word_aligned( std::uint16_t v ) {
        return v << LogBytesPerWord;
    }


    std::int32_t oops_offset() const {
        return unpack_word_aligned( _oopsOffset );
    }


    std::int32_t value_offset() const {
        return unpack_word_aligned( _valueOffset );
    }


    std::int32_t pcs_offset() const {
        return unpack_word_aligned( _pcsOffset );
    }


    // Return the address after the struct header
    std::uint8_t *start() const {
        return (std::uint8_t *) ( this + 1 );
    }


public: // for debugging
    Oop *oops() const {
        return (Oop *) ( start() + oops_offset() );
    }


    std::int32_t oops_size() const {
        return ( value_offset() - oops_offset() ) / sizeof( Oop );
    }


    Oop oop_at( std::int32_t index ) const {
        st_assert( index < oops_size(), "oops index out of range" );
        return oops()[ index ];
    }


private:
    std::int32_t *values() const {
        return (std::int32_t *) ( start() + value_offset() );
    }


    std::int32_t value_size() const {
        return ( pcs_offset() - value_offset() ) / sizeof( std::int32_t );
    }


    std::int32_t value_at( std::int32_t index ) const {
        st_assert( index < value_size(), "oops index out of range" );
        return values()[ index ];
    }


    inline std::uint8_t getIndexAt( std::int32_t &offset ) const;

    inline Oop unpackOopFromIndex( std::uint8_t index, std::int32_t &offset ) const;

    inline std::int32_t unpackValueFromIndex( std::uint8_t index, std::int32_t &offset ) const;

private:
    friend class ScopeDescriptorRecorder;


    void set_nativeMethodOffset( std::int32_t v ) {
        _nativeMethodOffset = v;
    }


    void set_length( std::int32_t v ) {
        _length = pack_word_aligned( v );
    }


    void set_oops_offset( std::int32_t v ) {
        _oopsOffset = pack_word_aligned( v );
    }


    void set_value_offset( std::int32_t v ) {
        _valueOffset = pack_word_aligned( v );
    }


    void set_pcs_offset( std::int32_t v ) {
        _pcsOffset = pack_word_aligned( v );
    }


    void set_dependents_end( std::int32_t v ) {
        _dependentsEnd = v;
    }


public:
    KlassOop dependent_at( std::int32_t index ) const {
        st_assert( index >= 0 and index < dependent_length(), "must be within bounds" );
        Oop result = oop_at( index );
        st_assert( result->is_klass(), "must be klass" );
        return KlassOop( result );
    }


    std::int32_t dependent_length() const {
        return _dependentsEnd;
    }


    void *pcs() const {
        return (void *) ( start() + pcs_offset() );
    }


    void *pcsEnd() const {
        return (void *) end();
    }


    std::int32_t length() const {
        return unpack_word_aligned( _length );
    }


    NativeMethod *my_nativeMethod() const {
        return (NativeMethod *) ( ( (const char *) this ) - _nativeMethodOffset );
    };


    // returns the address following this NativeMethodScopes.
    ScopeDescriptor *end() const {
        return (ScopeDescriptor *) ( start() + length() );
    }


    bool includes( ScopeDescriptor *d ) const {
        return this == d->_scopes;
    }


    // Returns the root scope without pc specific information.
    // The returned scope cannot be used for retrieving name desc information.
    ScopeDescriptor *root() const {
        return at( 0, ScopeDescriptor::invalid_pc );
    }


    std::int32_t size() const {
        return sizeof( NativeMethodScopes ) + length();
    }


    // Returns a scope located at offset.
    ScopeDescriptor *at( std::int32_t offset, const char *pc ) const;

    NonInlinedBlockScopeDescriptor *noninlined_block_scope_at( std::int32_t offset ) const;


    // used in iterator macro FOR_EACH_SCOPE
    ScopeDescriptor *getNext( ScopeDescriptor *s ) const {
        if ( not s )
            return root();
        std::int32_t offset = s->next_offset();

        if ( offset + ( sizeof( std::int32_t ) - ( offset % sizeof( std::int32_t ) ) ) % sizeof( std::int32_t ) >= ( _oopsOffset ) * sizeof( Oop ) )
            return nullptr;

        return at( offset, ScopeDescriptor::invalid_pc );
    }


    std::uint8_t get_next_char( std::int32_t &offset ) const {
        return *( start() + offset++ );
    }


    std::int16_t get_next_half( std::int32_t &offset ) const;


    std::uint8_t peek_next_char( std::int32_t offset ) const {
        return *( start() + offset );
    }


    Oop unpackOopAt( std::int32_t &offset ) const;

    std::int32_t unpackValueAt( std::int32_t &offset ) const;

    void iterate( std::int32_t &offset, UnpackClosure *closure ) const;    // iterates over a string of NameDescs (iterator is not called at termination)
    NameDescriptor *unpackNameDescAt( std::int32_t &offset, const char *pc ) const;    // Unpacks a string of name descs and returns one matching the pc

private:
    NameDescriptor *unpackNameDescAt( std::int32_t &offset, bool &is_last, const char *pc ) const;    // Unpacks a single name desc at offset

public:

    // Support for garbage collection.
    void oops_do( void f( Oop * ) );

    void scavenge_contents();

    void switch_pointers( Oop from, Oop to, GrowableArray<NativeMethod *> *nativeMethods_to_invalidate );

    bool is_new() const;

    void relocate();

    void verify();

    void print();

    // Prints (dep d% oops %d bytes %d pcs %d)
    void print_partition();
};
